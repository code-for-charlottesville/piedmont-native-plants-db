/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AccountResponse,
  PaginatedPlantIdentifierList,
  PaginatedPlantInformationList,
  PaginatedPlantList,
  PatchedPlant,
  PatchedPlantIdentifier,
  PatchedPlantInformation,
  Plant,
  PlantIdentifier,
  PlantInformation,
  SignInRequest,
  SignUpRequest,
  UserResponse,
} from '../models';
import {
    AccountResponseFromJSON,
    AccountResponseToJSON,
    PaginatedPlantIdentifierListFromJSON,
    PaginatedPlantIdentifierListToJSON,
    PaginatedPlantInformationListFromJSON,
    PaginatedPlantInformationListToJSON,
    PaginatedPlantListFromJSON,
    PaginatedPlantListToJSON,
    PatchedPlantFromJSON,
    PatchedPlantToJSON,
    PatchedPlantIdentifierFromJSON,
    PatchedPlantIdentifierToJSON,
    PatchedPlantInformationFromJSON,
    PatchedPlantInformationToJSON,
    PlantFromJSON,
    PlantToJSON,
    PlantIdentifierFromJSON,
    PlantIdentifierToJSON,
    PlantInformationFromJSON,
    PlantInformationToJSON,
    SignInRequestFromJSON,
    SignInRequestToJSON,
    SignUpRequestFromJSON,
    SignUpRequestToJSON,
    UserResponseFromJSON,
    UserResponseToJSON,
} from '../models';

export interface ApiSchemaRetrieveRequest {
    format?: ApiSchemaRetrieveFormatEnum;
    lang?: ApiSchemaRetrieveLangEnum;
}

export interface PlantCreateRequest {
    Plant: Plant;
}

export interface PlantDestroyRequest {
    id: number;
}

export interface PlantIdentCreateRequest {
    PlantIdentifier: PlantIdentifier;
}

export interface PlantIdentDestroyRequest {
    id: number;
}

export interface PlantIdentListRequest {
    common_name__icontains?: string;
    common_name__iexact?: string;
    latin_name__icontains?: string;
    latin_name__iexact?: string;
    page?: number;
}

export interface PlantIdentPartialUpdateRequest {
    id: number;
    PatchedPlantIdentifier?: PatchedPlantIdentifier;
}

export interface PlantIdentRetrieveRequest {
    id: number;
}

export interface PlantIdentUpdateRequest {
    id: number;
    PlantIdentifier: PlantIdentifier;
}

export interface PlantInfCreateRequest {
    PlantInformation?: PlantInformation;
}

export interface PlantInfDestroyRequest {
    id: number;
}

export interface PlantInfListRequest {
    bloom_end?: PlantInfListBloomEndEnum;
    bloom_start?: PlantInfListBloomStartEnum;
    height_max?: number;
    height_max__gt?: number;
    height_max__lt?: number;
    height_min?: number;
    height_min__gt?: number;
    height_min__lt?: number;
    page?: number;
}

export interface PlantInfPartialUpdateRequest {
    id: number;
    PatchedPlantInformation?: PatchedPlantInformation;
}

export interface PlantInfRetrieveRequest {
    id: number;
}

export interface PlantInfUpdateRequest {
    id: number;
    PlantInformation?: PlantInformation;
}

export interface PlantListRequest {
    datetime_added?: Date;
    datetime_added__day?: number;
    datetime_added__gt?: Date;
    datetime_added__hour?: number;
    datetime_added__in?: Array<Date>;
    datetime_added__lt?: Date;
    datetime_added__month?: number;
    datetime_added__year?: number;
    description__icontains?: string;
    page?: number;
}

export interface PlantPartialUpdateRequest {
    id: number;
    PatchedPlant?: PatchedPlant;
}

export interface PlantRetrieveRequest {
    id: number;
}

export interface PlantUpdateRequest {
    id: number;
    Plant: Plant;
}

export interface UserSigninRequest {
    SignInRequest: SignInRequest;
}

export interface UserSignupRequest {
    SignUpRequest: SignUpRequest;
}

/**
 * 
 */
export class ApiApi extends runtime.BaseAPI {

    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     */
    async apiSchemaRetrieveRaw(requestParameters: ApiSchemaRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>> {
        const queryParameters: any = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.lang !== undefined) {
            queryParameters['lang'] = requestParameters.lang;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/schema/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     */
    async apiSchemaRetrieve(requestParameters: ApiSchemaRetrieveRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }> {
        const response = await this.apiSchemaRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantCreateRaw(requestParameters: PlantCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Plant>> {
        if (requestParameters.Plant === null || requestParameters.Plant === undefined) {
            throw new runtime.RequiredError('Plant','Required parameter requestParameters.Plant was null or undefined when calling plantCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/plants/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlantToJSON(requestParameters.Plant),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantCreate(requestParameters: PlantCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Plant> {
        const response = await this.plantCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantDestroyRaw(requestParameters: PlantDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/plants/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantDestroy(requestParameters: PlantDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.plantDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentCreateRaw(requestParameters: PlantIdentCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlantIdentifier>> {
        if (requestParameters.PlantIdentifier === null || requestParameters.PlantIdentifier === undefined) {
            throw new runtime.RequiredError('PlantIdentifier','Required parameter requestParameters.PlantIdentifier was null or undefined when calling plantIdentCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/identifiers/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlantIdentifierToJSON(requestParameters.PlantIdentifier),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantIdentifierFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentCreate(requestParameters: PlantIdentCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlantIdentifier> {
        const response = await this.plantIdentCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentDestroyRaw(requestParameters: PlantIdentDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantIdentDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/identifiers/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentDestroy(requestParameters: PlantIdentDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.plantIdentDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentListRaw(requestParameters: PlantIdentListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPlantIdentifierList>> {
        const queryParameters: any = {};

        if (requestParameters.common_name__icontains !== undefined) {
            queryParameters['common_name__icontains'] = requestParameters.common_name__icontains;
        }

        if (requestParameters.common_name__iexact !== undefined) {
            queryParameters['common_name__iexact'] = requestParameters.common_name__iexact;
        }

        if (requestParameters.latin_name__icontains !== undefined) {
            queryParameters['latin_name__icontains'] = requestParameters.latin_name__icontains;
        }

        if (requestParameters.latin_name__iexact !== undefined) {
            queryParameters['latin_name__iexact'] = requestParameters.latin_name__iexact;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/identifiers/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPlantIdentifierListFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentList(requestParameters: PlantIdentListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPlantIdentifierList> {
        const response = await this.plantIdentListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentPartialUpdateRaw(requestParameters: PlantIdentPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlantIdentifier>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantIdentPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/identifiers/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPlantIdentifierToJSON(requestParameters.PatchedPlantIdentifier),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantIdentifierFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentPartialUpdate(requestParameters: PlantIdentPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlantIdentifier> {
        const response = await this.plantIdentPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentRetrieveRaw(requestParameters: PlantIdentRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlantIdentifier>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantIdentRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/identifiers/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantIdentifierFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentRetrieve(requestParameters: PlantIdentRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlantIdentifier> {
        const response = await this.plantIdentRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentUpdateRaw(requestParameters: PlantIdentUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlantIdentifier>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantIdentUpdate.');
        }

        if (requestParameters.PlantIdentifier === null || requestParameters.PlantIdentifier === undefined) {
            throw new runtime.RequiredError('PlantIdentifier','Required parameter requestParameters.PlantIdentifier was null or undefined when calling plantIdentUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/identifiers/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PlantIdentifierToJSON(requestParameters.PlantIdentifier),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantIdentifierFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantIdentUpdate(requestParameters: PlantIdentUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlantIdentifier> {
        const response = await this.plantIdentUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfCreateRaw(requestParameters: PlantInfCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlantInformation>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/information/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlantInformationToJSON(requestParameters.PlantInformation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantInformationFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfCreate(requestParameters: PlantInfCreateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlantInformation> {
        const response = await this.plantInfCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfDestroyRaw(requestParameters: PlantInfDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantInfDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/information/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfDestroy(requestParameters: PlantInfDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.plantInfDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfListRaw(requestParameters: PlantInfListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPlantInformationList>> {
        const queryParameters: any = {};

        if (requestParameters.bloom_end !== undefined) {
            queryParameters['bloom_end'] = requestParameters.bloom_end;
        }

        if (requestParameters.bloom_start !== undefined) {
            queryParameters['bloom_start'] = requestParameters.bloom_start;
        }

        if (requestParameters.height_max !== undefined) {
            queryParameters['height_max'] = requestParameters.height_max;
        }

        if (requestParameters.height_max__gt !== undefined) {
            queryParameters['height_max__gt'] = requestParameters.height_max__gt;
        }

        if (requestParameters.height_max__lt !== undefined) {
            queryParameters['height_max__lt'] = requestParameters.height_max__lt;
        }

        if (requestParameters.height_min !== undefined) {
            queryParameters['height_min'] = requestParameters.height_min;
        }

        if (requestParameters.height_min__gt !== undefined) {
            queryParameters['height_min__gt'] = requestParameters.height_min__gt;
        }

        if (requestParameters.height_min__lt !== undefined) {
            queryParameters['height_min__lt'] = requestParameters.height_min__lt;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/information/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPlantInformationListFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfList(requestParameters: PlantInfListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPlantInformationList> {
        const response = await this.plantInfListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfPartialUpdateRaw(requestParameters: PlantInfPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlantInformation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantInfPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/information/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPlantInformationToJSON(requestParameters.PatchedPlantInformation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantInformationFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfPartialUpdate(requestParameters: PlantInfPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlantInformation> {
        const response = await this.plantInfPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfRetrieveRaw(requestParameters: PlantInfRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlantInformation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantInfRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/information/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantInformationFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfRetrieve(requestParameters: PlantInfRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlantInformation> {
        const response = await this.plantInfRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfUpdateRaw(requestParameters: PlantInfUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlantInformation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantInfUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/information/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PlantInformationToJSON(requestParameters.PlantInformation),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantInformationFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantInfUpdate(requestParameters: PlantInfUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlantInformation> {
        const response = await this.plantInfUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantListRaw(requestParameters: PlantListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPlantList>> {
        const queryParameters: any = {};

        if (requestParameters.datetime_added !== undefined) {
            queryParameters['datetime_added'] = (requestParameters.datetime_added as any).toISOString();
        }

        if (requestParameters.datetime_added__day !== undefined) {
            queryParameters['datetime_added__day'] = requestParameters.datetime_added__day;
        }

        if (requestParameters.datetime_added__gt !== undefined) {
            queryParameters['datetime_added__gt'] = (requestParameters.datetime_added__gt as any).toISOString();
        }

        if (requestParameters.datetime_added__hour !== undefined) {
            queryParameters['datetime_added__hour'] = requestParameters.datetime_added__hour;
        }

        if (requestParameters.datetime_added__in) {
            queryParameters['datetime_added__in'] = requestParameters.datetime_added__in.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.datetime_added__lt !== undefined) {
            queryParameters['datetime_added__lt'] = (requestParameters.datetime_added__lt as any).toISOString();
        }

        if (requestParameters.datetime_added__month !== undefined) {
            queryParameters['datetime_added__month'] = requestParameters.datetime_added__month;
        }

        if (requestParameters.datetime_added__year !== undefined) {
            queryParameters['datetime_added__year'] = requestParameters.datetime_added__year;
        }

        if (requestParameters.description__icontains !== undefined) {
            queryParameters['description__icontains'] = requestParameters.description__icontains;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/plants/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPlantListFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantList(requestParameters: PlantListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPlantList> {
        const response = await this.plantListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantPartialUpdateRaw(requestParameters: PlantPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Plant>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/plants/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPlantToJSON(requestParameters.PatchedPlant),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantPartialUpdate(requestParameters: PlantPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Plant> {
        const response = await this.plantPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantRetrieveRaw(requestParameters: PlantRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Plant>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/plants/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantRetrieve(requestParameters: PlantRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Plant> {
        const response = await this.plantRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantUpdateRaw(requestParameters: PlantUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Plant>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling plantUpdate.');
        }

        if (requestParameters.Plant === null || requestParameters.Plant === undefined) {
            throw new runtime.RequiredError('Plant','Required parameter requestParameters.Plant was null or undefined when calling plantUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/plants/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PlantToJSON(requestParameters.Plant),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlantFromJSON(jsonValue));
    }

    /**
     * __Uses PrivilegedOrReadOnlyAuthenticated Permissions__:  If the user is an admin or staff member, then _all_ operations are available to them;  otherwise, the api defaults to _readonly_ operations. The user must be _authenticated_ in _both_ cases. * If the user is privileged (`is_staff or is_superuser == True`), then they can use: __all operations__ * If the user is not privileged (`is_staff or is_superuser == False`), then they can use: __list__ or __retrieve__ operations
     */
    async plantUpdate(requestParameters: PlantUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Plant> {
        const response = await this.plantUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a user tied to the token header given by `Authorization: Token \'%s\'`
     */
    async userAccountRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/auth/account/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a user tied to the token header given by `Authorization: Token \'%s\'`
     */
    async userAccount(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountResponse> {
        const response = await this.userAccountRaw(initOverrides);
        return await response.value();
    }

    /**
     * Signs the user into the API and returns a token to be used in subsequent requests.
     */
    async userSigninRaw(requestParameters: UserSigninRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters.SignInRequest === null || requestParameters.SignInRequest === undefined) {
            throw new runtime.RequiredError('SignInRequest','Required parameter requestParameters.SignInRequest was null or undefined when calling userSignin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/auth/signin/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignInRequestToJSON(requestParameters.SignInRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Signs the user into the API and returns a token to be used in subsequent requests.
     */
    async userSignin(requestParameters: UserSigninRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.userSigninRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the current token within the `Authorization` header. Effectively, this logs the user out of the application.  __Note__: This does not delete _all_ tokens, only the one currently in the header. To delete all tokens (sign the user out of all sessions), one should use `sign_out_all`.
     */
    async userSignoutRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/auth/signout/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the current token within the `Authorization` header. Effectively, this logs the user out of the application.  __Note__: This does not delete _all_ tokens, only the one currently in the header. To delete all tokens (sign the user out of all sessions), one should use `sign_out_all`.
     */
    async userSignout(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.userSignoutRaw(initOverrides);
    }

    /**
     * Deletes all authentication tokens tied to the user. The post request must have a valid token within the `Authorization` header. This is used to specify the user to logout. Effectively, this view logs the user out of all active sessions.  __Note__: To logout of a _single_ session, one can use the `sign_out` operation.
     */
    async userSignoutAllRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // KnoxTokenAuthentication authentication
        }

        const response = await this.request({
            path: `/api/auth/signoutall/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes all authentication tokens tied to the user. The post request must have a valid token within the `Authorization` header. This is used to specify the user to logout. Effectively, this view logs the user out of all active sessions.  __Note__: To logout of a _single_ session, one can use the `sign_out` operation.
     */
    async userSignoutAll(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.userSignoutAllRaw(initOverrides);
    }

    /**
     * Signs the user up for the API and returns a token to be used in subsequent requests.
     */
    async userSignupRaw(requestParameters: UserSignupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters.SignUpRequest === null || requestParameters.SignUpRequest === undefined) {
            throw new runtime.RequiredError('SignUpRequest','Required parameter requestParameters.SignUpRequest was null or undefined when calling userSignup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/auth/signup/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignUpRequestToJSON(requestParameters.SignUpRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Signs the user up for the API and returns a token to be used in subsequent requests.
     */
    async userSignup(requestParameters: UserSignupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.userSignupRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ApiSchemaRetrieveFormatEnum = {
    json: 'json',
    yaml: 'yaml'
} as const;
export type ApiSchemaRetrieveFormatEnum = typeof ApiSchemaRetrieveFormatEnum[keyof typeof ApiSchemaRetrieveFormatEnum];
/**
 * @export
 */
export const ApiSchemaRetrieveLangEnum = {
    af: 'af',
    ar: 'ar',
    ar_dz: 'ar-dz',
    ast: 'ast',
    az: 'az',
    be: 'be',
    bg: 'bg',
    bn: 'bn',
    br: 'br',
    bs: 'bs',
    ca: 'ca',
    ckb: 'ckb',
    cs: 'cs',
    cy: 'cy',
    da: 'da',
    de: 'de',
    dsb: 'dsb',
    el: 'el',
    en: 'en',
    en_au: 'en-au',
    en_gb: 'en-gb',
    eo: 'eo',
    es: 'es',
    es_ar: 'es-ar',
    es_co: 'es-co',
    es_mx: 'es-mx',
    es_ni: 'es-ni',
    es_ve: 'es-ve',
    et: 'et',
    eu: 'eu',
    fa: 'fa',
    fi: 'fi',
    fr: 'fr',
    fy: 'fy',
    ga: 'ga',
    gd: 'gd',
    gl: 'gl',
    he: 'he',
    hi: 'hi',
    hr: 'hr',
    hsb: 'hsb',
    hu: 'hu',
    hy: 'hy',
    ia: 'ia',
    id: 'id',
    ig: 'ig',
    io: 'io',
    is: 'is',
    it: 'it',
    ja: 'ja',
    ka: 'ka',
    kab: 'kab',
    kk: 'kk',
    km: 'km',
    kn: 'kn',
    ko: 'ko',
    ky: 'ky',
    lb: 'lb',
    lt: 'lt',
    lv: 'lv',
    mk: 'mk',
    ml: 'ml',
    mn: 'mn',
    mr: 'mr',
    ms: 'ms',
    my: 'my',
    nb: 'nb',
    ne: 'ne',
    nl: 'nl',
    nn: 'nn',
    os: 'os',
    pa: 'pa',
    pl: 'pl',
    pt: 'pt',
    pt_br: 'pt-br',
    ro: 'ro',
    ru: 'ru',
    sk: 'sk',
    sl: 'sl',
    sq: 'sq',
    sr: 'sr',
    sr_latn: 'sr-latn',
    sv: 'sv',
    sw: 'sw',
    ta: 'ta',
    te: 'te',
    tg: 'tg',
    th: 'th',
    tk: 'tk',
    tr: 'tr',
    tt: 'tt',
    udm: 'udm',
    uk: 'uk',
    ur: 'ur',
    uz: 'uz',
    vi: 'vi',
    zh_hans: 'zh-hans',
    zh_hant: 'zh-hant'
} as const;
export type ApiSchemaRetrieveLangEnum = typeof ApiSchemaRetrieveLangEnum[keyof typeof ApiSchemaRetrieveLangEnum];
/**
 * @export
 */
export const PlantInfListBloomEndEnum = {
    Apr: 'Apr',
    Aug: 'Aug',
    Dec: 'Dec',
    Feb: 'Feb',
    Jan: 'Jan',
    Jul: 'Jul',
    Jun: 'Jun',
    Mar: 'Mar',
    May: 'May',
    Nil: 'Nil',
    Nov: 'Nov',
    Oct: 'Oct',
    Sep: 'Sep'
} as const;
export type PlantInfListBloomEndEnum = typeof PlantInfListBloomEndEnum[keyof typeof PlantInfListBloomEndEnum];
/**
 * @export
 */
export const PlantInfListBloomStartEnum = {
    Apr: 'Apr',
    Aug: 'Aug',
    Dec: 'Dec',
    Feb: 'Feb',
    Jan: 'Jan',
    Jul: 'Jul',
    Jun: 'Jun',
    Mar: 'Mar',
    May: 'May',
    Nil: 'Nil',
    Nov: 'Nov',
    Oct: 'Oct',
    Sep: 'Sep'
} as const;
export type PlantInfListBloomStartEnum = typeof PlantInfListBloomStartEnum[keyof typeof PlantInfListBloomStartEnum];
